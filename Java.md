## 글을 읽기 전

---

주석은 의미가 없다는 뜻이거나 중요하지 않으니깐 대충 보고 넘기세요.

## 0. 자바 시작하기

---

### 자바의 특징

- **객체 지향 언어**이다.
- 함수형 코딩을 지원한다.
- 분산 처리를 지원한다.
- *//대충 자바가 좋으니깐 쓰라는 특징들*

### JDK와 JRE, JVM

- JDK : 자바 프로그램 **개발**하고 **실행** 위해 반드시 설치
    
    *//컴파일러, 디버거, 애플릿뷰어 등*
    
- JRE : 자바 프로그램 **실행**만 할 경우 설치
    
    *//클래스 로더, 자바 API, 실행 시간 라이브러리 등*
    
- JVM : *//JRE와 용도 같음*
    
    *//JIT 컴파일러, 자바 인터프리터 등*
    
- JDK
    - JRE
        - JVM
            
            *//이 순서임*
            

### **프로그램 작성과 실행 순서**

1. 프로젝트 생성
2. 자바 프로그램 코딩 (*.java)
3. 바이트 코드 생성 (*.class)
4. 실행

## 0-1. 자바 프로그램의 구조와 기본 입출력

---

### *//자바 프로그램 기본 구조*

- *//소스 파일*
    - *//클래스*
        - *//메서드*
            - *//실행문*
                
                *//이 순서임*
                

### 키보드로 데이터 입력

```java
*// 프로그램의 첫 행에 다음을 추가해 Scanner 클래스의 경로 이름을 컴파일러에게 알린다.
import java.util.Scanner;*

// 키보드로 데이터를 입력받으라고 System.in 객체와 연결된 Scanner 객체를 생성한다.
**Scanner in = new Scanner(System.in);**

*// Scanner 클래스가 제공하는 다양한 메소드를 이용해 키보드로 데이터를 입력받는다.
int x = in.nextInt(); // 정수를 읽어 변수 x에 대입*
```

## 0-2. 변수와 타입

---

### 변수 표기법

- **카멜 표기법**
    
    변수 명명 규칙
    
    *//ex. int backgroundColor; String userName;*
    
- **파스칼 표기법**
    
    클래스 명명 규칙
    
    *//ex. BackgroundColor, Exvariable*
    
- ***//헝가리안 표기법***
    
    *//ex. int nTest; String sTest; float fTest; double dTest;*
    
- ***//스네이크 표기법***
    
    *//ex. int num_test; String user_name;*
    

### 자바의 데이터 타입

- ***//기초 타입***
    
    *//정수 타입 : byte, short, int, long*
    
    *//문자 타입 : char*
    
    *//실수 타입 : float, double*
    
    *//논리 타입 : boolean*
    
- **참조 타입**
    
    배열 타입
    
    열거 타입
    
    클래스 타입
    
    인터페이스 타입
    

### *//기초 타입*

| 정수 | byte | 1 byte |
| --- | --- | --- |
| “ | char | 2 byte |
| “ | short | 2 byte |
| “ | int | 4 byte |
| “ | long | 8 byte |
| 실수 | float | 4 byte |
| “ | double | 8 byte |
| 논리 | boolean | 1 byte |

### 타입 변환

- 자동 타입 변환 : Promotion
    
    큰 크기 타입 <— *자동 타입 변환* — 작은 크기 타입
    
    *//자동 타입 변환은 코드를 주고 자동 타입 변환이 일어난 부분을 찾으라고 할 문제가 나올 가능성이 높다.*
    
    *//꼭 자바 유인물을 확인하여 완벽히 이해하고 넘어가자.* 
    
- 강제 타입 변환 : Casting
    
    작은 크기 타입 <— *강제 타입 변환* — (작은 크기 타입) 큰 크기 타입
    

## 0-3. 연산자

---

*//대부분 잘 알고 있어할 것 같아서 생략*

- 논리 연산자
- 삼항 연산자

- *//(1 > 2 && 1 > 3) 여기서 1 > 2 가 성립하지 않으니깐 1 > 3 을 검사 안함*
- *//응용하면 a = 1; b = 3; (++a > b && ++a > b) 이러면 a는 2임*

## 0-4. 조건문과 반복문

---

*//switch, continue는 생략*

### break문 종료

특정 for문 종료는 for문 앞에 라벨명 붙이고 break 라벨명; 사용

```java
Label:for(...) {
	for(...) {
		break Label;
	}
}
```

## 2. 배열

---

### 배열 선언

- 타입[] 변수;
    
    *//ex. int[] intArray;*
    
- 배열 = 객체

### New 연산자로 배열 생성

- 타입[] 변수 = new 타입[길이];
    
    *//ex. int[] intArray = new int[3];*
    

### 배열 길이

- 배열변수.length;

### 다차원 배열

- int[][] scores = new int[2][3];
- 위 구문에서 생성되는 객체의 개수는 [2] 에서 1개를 더 추가한 세 개의 배열 객체가 생성된다.

### 객체를 참조하는 배열

- String은 클래스 타입이므로, String[] 배열은 각 항목에 문자열이 아니라, String 객체의 주소를 가지고 있다.
    
    *//다른 자료형인 int, float와는 다르게 String만 첫 글자가 대문자로 시작하는 파스칼 표기법이다.*
    
- String[] 배열 항목 간에 **문자열을 비교하기 위해서는 == 연산자 대신 equals() 메소드**를 사용해야 한다.

### *//배열 복사*

- *//System.arraycopy() 메소드*

## 2-0. 열거 타입

---

### 열거 타입 선언

- 한정된 값만을 갖는 데이터 타입
- 선언을 위해서는 열거 타입 이름으로 소스 파일 (*.java) 을 생성해야 한다.

### 열거 타입 변수

- 열거 상수는 단독으로 사용할 수 없고, 반드시 “열거타입.열거상수” 형식으로 사용해야 한다.
- **열거 상수는 객체이다.**

## 3. 클래스

---

### 객체지향 프로그래밍

- 객체를 모델링하고 집합 관계에 있는 부품 객체와 사용 관계에 있는 객체를 하나씩 설계한 후 조립하는 방식으로 프로그램을 개발하는 기법

### 객체

- **물리적으로 존재**하거나 **추상적으로 생각**할 수 있는 것
- 자신의 속성을 가지고 있고, 다른 것과 식별 가능한 것

### 객체의 상호작용

- 객체들 사이의 상호작용 수단은 메소드

### **객체 간의 관계**

- 집합 관계
    
    객체는 하나는 부품이고 하나는 완성품
    
- 사용 관계
    
    객체 간의 상호작용
    
- 상속 관계
    
    상위 객체를 기반으로 하위 객체를 생성
    

### **객체 지향 프로그래밍의 특징**

- 캡슐화
    
    실제 구현 내용 감추는 것
    
    **접근 제한자**를 사용하여 노출시킬 것인지, 숨길 것인지 결정
    
- 상속
    
    상위 객체를 재사용하여 하위 객체를 쉽고 빨리 설계
    
    반복된 코드의 중복 제거, 유지 보수 시간 최소화
    
    *//[상속 챕터로 돌아가기](https://www.notion.so/16c56c3e29f348a4a3200fbd5b1822ab)*
    
- 다형성
    
    하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 함.
    

### 클래스의 용도

- 라이브러리용
    
    다른 클래스에서 이용할 목적으로 설계
    
- 실행용
    
    main() 메소드를 제공하는 역할
    

### 변수와 필드의 차이점

- 변수
    
    생성자와 메소드 내에서만 사용
    
    생성자와 메소드가 실행 종료되면 자동 소멸
    
- 필드
    
    클래스 내부 전체에서 사용
    
    객체가 소멸되지 않는 한 객체와 함께 존재
    

### 필드

- 클래스 내부 : 단순히 필드 이름으로 읽고 변경한다.
- 클래스 외부 : 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용한다.

### 메소드 이름 명명 규칙

- 숫자로 시작하면 안되고 $와 _를 제외한 특수 문자 사용 불가
- 관례적으로 메소드명은 [**카멜 표기법**](https://www.notion.so/16c56c3e29f348a4a3200fbd5b1822ab)을 사용한다.

### 매개 변수의 수를 모를 경우

- 메소드의 매개 변수를 “...”를 사용해서 선언

### 메소드 호출

- 클래스 내부에서 호출 : 단순한 메소드 이름으로 호출
- 클래스 외부에서 호출 : 클래스로부터 객체를 생성한 뒤, 참조 변수를 이용하여 메소드 호출

### 메소드 오버로딩 (Overloading)

- 리턴 타입만 바꾸거나, 매개 변수의 이름만 바꿀 경우 메소드 오버로딩이 성립되지 않음
- 오버로딩된 메소드를 호출할 경우 **JVM은 매개값의 타입을 보고 메소드 선택**함.
- 매개 변수의 타입이 일치하지 않을 경우, **자동 타입 변환이 가능한지를 검사**함.

### 인스턴스 멤버와 정적 멤버 선언할 판단 기준

1. 필드
    - 객체마다 가지고 있어야 할 데이터일 시 : **인스턴스 필드**
    - 객체마다 가지고 있을 필요가 없는 데이터일 시 : **정적 필드**
2. 메소드
    - 인스턴스 필드를 사용해야 할 시 : **인스턴스 메소드**
    - 인스턴스 필드를 사용하지 않을 시 : **정적 메소드**
    

### 정적 멤버

- **정적 필드는 생성자에서 초기화 작업을 할 수 없다.**
- 자바에서 정적 필드의 초기화 작업을 위해 **정적 블록** 제공
- 정적 블록은 클래스 내부에 **여러 개가 선언되어도 상관 없다**만, **선언된 순서대로 실행**된다.

### final 필드

- 프로그램 실행 도중 수정 불가능
- final 필드에 초기값 주는 2가지 방법
    1. 필드 선언 시에 주는 방법
    2. 생성자에서 주는 방법

### final vs constant

- *//상수 (CONSTant) : (1, 2, “a”, “b”) 와 같이 언제 어디서든 절대 변할 일이 없는 값*
- final 필드는 constant 와는 다르게...
    1. 객체마다 다르게 저장될 수 있다.
    2. 생성자의 매개값을 통해서 여러 가지 값을 가질 수 있다.
- final 필드는 한 번 초기값이 저장되면 변경할 수 없다.

### 패키지 명명 규칙

- 숫자로 시작해서는 안되고 $와 _를 제외한 특수 문자를 사용해서는 안된다.
- **java로 시작해서는 안된다.**
- 모두 소문자이다, **파스칼 표기법이 아니다.**

### 접근 제한자

| public | 클래스, 필드, 생성자, 메소드 | 없음 |
| --- | --- | --- |
| protected | 필드, 생성자, 메소드 | 자식 클래스가 아닌 다른 패키지의 클래스 |
| default | 클래스, 필드, 생성자, 메소드 | 다른 패키지의 클래스 |
| private | 필드, 생성자, 메소드 | 모든 외부 클래스 |

| public | 올 all |
| --- | --- |
| protected | 클 -class |
| default | 올 all |
| private | 클 -class |

### Getter 와 Setter 메소드

- **객체의 무결성** *이 깨지지 않도록 메소드를 통해 데이터를 변경하는 방법*
- 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문

## 상속

---

> [**상속 개념**](https://www.notion.so/16c56c3e29f348a4a3200fbd5b1822ab)
> 

### 클래스 상속

- **자바는 다중 상속을 허용하지 않는다.**

### 부모 생성자 호출

- 자식 객체를 생성하면 **부모 객체가 먼저 생성**되고 그 다음에 자식 객체가 생성된다.
- 명시적으로 부모 생성자를 호출하는 경우 매개값의 타입과 일치하는 부모 생성자가 없다면 컴파일 오류가 발생한다.

### 메소드 재정의 (Override) 규칙

- **부모의 메소드와 동일한 시그니처를 가져야 한다.**
- **접근 제한을 더 강하게 오버라이딩할 수 없다.**
- **새로운 예외를 throws 할 수 없다.**

### 재정의된 부모 클래스의 메소드 호출 방법

- 명시적으로 super 키워드를 붙여서 부모 메소드를 호출

```java
super.parentMethod();
```

### final 멤버

- final 필드 : 초기값 설정 후, 더 이상 값을 변경할 수 없다.
- final 클래스 : 부모 클래스가 될 수 없어 (= 상속할 수 없어) 자식 클래스를 만들 수 없다.
- final 메소드 : 오버라이딩할 수 없는 메소드

### 자동 타입 변환 (Promotion)

- 부모클래스 변수 <— *자동 타입 변환* — 자식클래스타입 *//띄어쓰기에 유의*
    
    부모 타입으로 자동 타입 변환된 이후 **접근 가능한 멤버는 부모 클래스 멤버로만 한정**된다.
    
    그러나 부모 클래스 멤버들중 **오버라이딩된 메소드**라면 **자식 클래스의 메소드가 대신 호출**된다.
    
- *//자동 타입 변환은 코드를 주고 자동 타입 변환이 일어난 부분을 찾으라고 할 문제가 나올 가능성이 높다.*
- *//꼭 자바 유인물을 확인하여 완벽히 이해하고 넘어가자.*

### 강제 타입 변환 (Casting)

- 자식클래스 변수 <— *강제 타입 변환* — (자식 클래스) 부모클래스타입 *//띄어쓰기에 유의*
- 모든 부모 타입을 자식 클래스 타입으로 강제 변환할 수 있는 것은 아니다.
- 자식 타입이 부모 타입으로 자동 변환한 후, 다시 자식 타입으로 변환할 때 강제 타입 변환을 사용할 수 있다.
- *//강제 타입 변환 하는 경우*
    - *//만약 자식 타입에 선언된 필드와 메소드를 꼭 사용해야 한다면 강제 타입 변환 후에 자식 타입의 필드와 메소드 사용*

### 객체 타입 확인 (instanceof)

- instanceof 연산자를 사용하여 어떤 클래스의 인스턴스인지 확인할 수 있다.

```java
boolean result = lObject instanceof rType;
//좌항(객체) instanceof 우항(타입)
//좌항의 객체가 우항의 인스턴스이면 true 아니면 false
```

## 추상 클래스

---

### 추상 클래스의 개념

- 추상(abstract)은 실체 간에 공통되는 특성을 추출한 것
- 추상 클래스와 실체 클래스는 상속의 관계를 갖고 있다.
- 추상 클래스는 새로운 실체 클래스를 만들기 위해 부모 클래스로만 사용된다.

### 추상 클래스의 용도

- 실체 클래스들의 공통된 필드와 메소드 이름을 통일할 목적
- 실체 클래스를 작성할 때 시간 절약
    - *//공통적인 필드와 메소드는 추상 클래스에 선언, 실체 클래스마다 다른 점만 실체 클래스에 선언하기 때문에 시간을 절약할 수 있다.*

### 추상 클래스 선언

```java
public abstract class ClassName
{
	//필드
	//생성자 <- 추상 클래스도 생성자가 반드시 있어야 한다.
	//메소드
}
```

### 추상 메소드와 오버라이딩

```java
public abstract void foo();
```

- 메소드의 선언부만 있고 메소드의 실행 내용인 {} 가 없는 메소드
- 추상 클래스를 설계할 때 하위 클래스가 반드시 실행 내용을 채우도록 강요하고 싶은 메소드가 있을 경우 위와 같이 추상 메소드로 선언하면 된다.
- *//자식 클래스는 반드시 추상 메소드를 재정의(@Override)해서 실행 내용을 작성해야 한다.*

## 인터페이스

---

### 인터페이스의 역할

- 개발 코드와 객체가 서로 통신하는 접점 역할

### 인터페이스 선언

```java
interface InterfaceName
{
	// 상수

	// 추상 메소드
	// 디폴트 메소드
	// 정적 메소드
}
```

- 상수 필드 선언 시 **public, static, final 생략 가능**
    - 다만 **인터페이스 상수는** static{} 블록으로 초기화가 불가능하여 **선언과 동시에 초기값을 지정해야 한다.**
- 추상 메소드 선언 시 **public abstract 생략 가능**
- 디폴드 메소드 선언 시 **public 만 생략 가능**
- 정적 메소드 선언 시 **public 만 생략 가능**

### 인터페이스 구현 객체 사용

- 인터페이스로 구현 객체 사용하려면 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.
- ex.

```java
인터페이스 변수;
변수 = 구현객체;
```

> 또는
> 

```java
인터페이스 변수 = 구현객체;
```

- **인터페이스 변수는 참조 타입이기에 구현 객체가 대입될 경우 구현 객체의 번지를 저장한다.**

### 익명 구현 객체

- 재사용 : 구현 클래스 사용
- 일회성 : 익명 구현 객체 사용

```java
인터페이스 변수 = new 인터페이스() {
	//인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

- *//중괄호 {} 안에 추상 메소드의 실체 메소드를 작성하지 않으면 컴파일 에러가 발생한다.*

### 인터페이스 사용

- 디폴트 메소드 사용
    - *//인터페이스에서 바로 사용할 수 없다.*
    - 디폴트 메소드는 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다.
- 정적 메소드 사용
    - 정적 메소드는 인터페이스로 바로 호출이 가능하다.

### 타입 변환과 다형성

- *//상속은 같은 조율의 하위 클래스를 만드는 기술*
- *//인터페이스는 사용 방법이 동일한 클래스를 만드는 기술*
- 개념적 차이점은 있지만 **상속과 인터페이스 모두 다형성을 구현하는 기술**

### 자동 타입 변환 (Promotion)

- 인터페이스 변수 <— *자동 타입 변환* — 구현객체 *//띄어쓰기에 유의*

### 강제 타입 변환 (Casting)

- 구현클래스 변수 <— *강제 타입 변환* — (구현클래스) 인터페이스변수 *//띄어쓰기에 유의*
- 구현 객체가 인터페이스 타입으로 자동 변환하면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다.
- *//경우에 따라 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우, 강제 타입 변환 후에 구현 클래스의 필드와 메소드를 사용*

### 인터페이스 상속

- **인터페이스는 클래스와는 달리 다중 상속을 허용한다.**
- 하위 인터페이스를 구현하는 클래스는 하위 인터페이스 메소드 뿐만이 아니라 상위 인터페이스의 모든 추상 메소드에 대한 실체 메소드를 가지고 있어야 한다.
- 따라서 구현 클래스로부터 객체를 생성 후에, 하위 및 상위 인터페이스 타입으로 변환 가능하다.
    
    ```java
    하위인터페이스 변수 = new 구현클래스(...);
    상위인터페이스1 변수 = new 구현클래스(...);
    상위인터페이스2 변수 = new 구현클래스(...);
    ```
    
    - 하위 인터페이스로 타입 변환 시 상 **·** 하위 인터페이스에 선언된 모든 메소드 사용 가능
    - 상위 인터페이스로 타입 변환 시 상위 인터페이스에 선언된 메소드만 사용 가능
        - *//하위 인터페이스에 선언된 메소드 사용 불가*
        

### 디폴트 메소드와 인터페이스 확장

- 기존에는 인터페이스에서 디폴트 메소드를 사용할 수 없었지만, 추후 (JVM 8+) 에 허용되었다.
- **기존 인터페이스를 확장해서 새로운 기능(메소드)을 추가**하기 위해서이다.

### 디폴트 메소드가 있는 인터페이스 상속

- 부모 인터페이스에 디폴트 메소드가 정의 되어 있을 경우, 자식 인터페이스에서 디폴트 메소드를 활용하는 방법은 다음과 같다.
1. 디폴트 메소드를 **단순히 상속만 받는다.**
2. 디폴트 메소드를 **재정의(Override)**해서 실행 내용을 변경한다.
3. 디폴트 메소드를 **추상 메소드로 재선언**한다.

## 글을 마치며

---

아무리 정리를 했어도 빠진 내용이 있거나, 제가 당신들이 알 거라고 생각하여 적지 않았던 내용을 당신들이 몰랐을 가능성이 있기 때문에 좀 번거로우시겠지만 자바 유인물을 전체적으로 정독하시는 것을 추천드립니다.

또한 자바 코드는 글에 적지 않았습니다. 이해를 하려면 자바 코드를 봐야 이해가 되는데 다시 한번 자바 코드를 보는 목적으로라도 자바 유인물을 꼭 확인해보세요.
