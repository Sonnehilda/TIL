# 자료 구조

---

# 🗳 스택 ( Stack )

---

스택은 push() 와 pop() 총 두 가지 연산을 적용할 수 있는 요소의 모음을 제공하는 추상 데이터 타입입니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled.png)

쉽게 구현할 수 있는 장점이 있지만 실용 가능성이 적습니다.

효율적인 데이터 관리가 가능하지만 제한된 크기를 가지고 있습니다.

하드웨어 요구 조건이 적지만 복사 & 붙여넣기가 어렵습니다.

# 🗃 큐 ( Queue )

---

큐는 개체들을 순차적으로 저장한 모음집입니다.

큐의 마지막 위치에 데이터가 삽입되고 처음 위치에서 데이터가 삭제됩니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%201.png)

많은 양의 데이터를 쉽고 효율적이게 관리할 수 있지만 제한된 크기를 가지고 있습니다.

처음 혹은 마지막 위치에 데이터를 삽입 혹은 삭제하는 것은 매우 안정적이게 수행될 수 있지만,

중간 위치에 데이터를 삽입 혹은 삭제하는 것은 매우 비효율적이게 수행됩니다.

# 🔒 해시 ( Hash )

---

해시는 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑(mapping)한 값입니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%202.png)

다른 자료 구조보다 나은 동기화를 제공하지만 데이터 간의 충돌이 잦을 때 비효율적입니다.

# 🗄 힙 ( Heap )

---

힙은 완전 이진 트리를 기반으로 한 자료 구조입니다.

힙은 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있습니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%203.png)

힙에 데이터를 저장하는 것은 실용 가능성과 가시성이 크지만 메모리 관리가 매우 복잡해 집니다.

그래프 알고리즘에 효율적으로 사용 가능하지만, 삽입 혹은 삭제를 수행하는 시간이 대부분의 자료 구조보다 더 깁니다.

# 🎞 2차원 배열 ( Two Dimensional Array )

---

2차원 배열은 1차원 배열과 비슷하지만, 테이블과 같이 행과 열로 시각화할 수 있습니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%204.png)

하나의 이름만을 사용하여 동일한 유형의 여러 데이터 항목을 나타내는 데 유용하지만, 한정된 크기를 가지고 있습니다.

# 🤑 탐욕 알고리즘 ( Greedy Algorithm )

---

탐욕 알고리즘은 선택의 기회가 올 때마다 최선의 선택만을 하는 알고리즘입니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%205.png)

다른 알고리즘에 비하여 구현하기 매우 쉽지만, 모든 데이터를 고려하지 않기 때문에 위의 사진과 같이 99 라는 가장 큰 데이터가 있음에도 불구하고 눈 앞의 선택지에서 큰 값만을 선택하기에 7의 위치에서 12를 고르게 됩니다.

# ⚙ 다이나믹 프로그래밍 ( Dynamic Programming )

---

다이나믹 프로그래밍은 큰 문제를 작은 문제로 나누어 풀지만, 메모이제이션 기법을 사용하여 하나의 문제를 단 한 번만 풀도록 하는 알고리즘입니다.

메모이제이션 기법은 이미 계산한 결과를 배열에 저장함으로써 나중에 동일한 계산을 해야 할 때 저장한 값을 단순히 반환하는 기법입니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%206.png)

## Bottom-up

---

작은 문제부터 차근차근 구해나아가는 방법입니다.

## Top-down

---

큰 문제를 풀 때 작은 문제가 아직 풀리지 않았다면 작은 문제를 해결합니다.

# 🔍너비 우선 탐색 ( BFS )

---

너비 우선 탐색은 트리 자료 구조 내에서 주어진 성질을 만족하는 노드를 탐색하는 알고리즘입니다.

트리의 루트에서 시작하여 현재 깊이의 모든 노드를 탐색하고 난 후 다음 깊이로 이동합니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%207.png)

찾으려는 값을 확실하게 찾을 수 있지만 현재 레벨에서 다음 레벨로 가기 위해 모든 노드를 저장하기에 메모리가 속박됩니다.

찾으려는 값이 하나 이상일 경우 최소한의 검색을 사용하여 찾지만 찾으려는 값이 멀리 있으면 많은 시간이 소요됩니다.

# 🔍 깊이 우선 탐색 ( DFS )

---

깊이 우선 탐색은 트리 혹은 그래프 자료 구조를 탐색하는 알고리즘입니다.

루트 노드에서 시작하여 (그래프일 경우 임의의 노드를 루트 노드로 설정합니다) 각 분기를 따라 최대한 먼 곳을 탐색하고 난 뒤 역 방향으로 다시 탐색합니다.

![Untitled](%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20071c1270eb2a4ea3ae700ddbaf16717f/Untitled%207.png)

너비 우선 탐색 ( BFS ) 보다 시간이 적게 들고 공간 복잡도가 적지만, 찾으려는 값을 확실하게 찾을 수 있을 지에 대하여는 보장되지 않습니다.

값을 찾고자 할 때 많은 검색이 필요하지 않을 수도 있지만, 단순 검색 속도 자체는 너비 우선 탐색 ( BFS )에 비하여 시간 복잡도가 높습니다.